/*=========================================================================

  Library:   CTK

  Copyright (c) Kitware Inc.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0.txt

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  This file was originally developed by Davide Punzo, punzodavide@hotmail.it,
  and development was supported by the Center for Intelligent Image-guided Interventions (CI3).

=========================================================================*/

#ifndef __ctkDICOMTaskPool_h
#define __ctkDICOMTaskPool_h

// Qt includes 
#include <QObject>
#include <QMap>

// ctkDICOMCore includes
#include "ctkDICOMCoreExport.h"
#include "ctkDICOMDatabase.h"

#include <ctkAbstractTaskPool.h>

class ctkAbstractTask;
class ctkDICOMIndexer;
class ctkDICOMTaskPoolPrivate;
class ctkDICOMServer;
class ctkDICOMTaskResults;

/// \ingroup DICOM_Core
class CTK_DICOM_CORE_EXPORT ctkDICOMTaskPool : public ctkAbstractTaskPool
{
  Q_OBJECT
  Q_PROPERTY(int maximumThreadCount READ maximumThreadCount WRITE setMaximumThreadCount);
  Q_PROPERTY(int maximumNumberOfRetry READ maximumNumberOfRetry WRITE setMaximumNumberOfRetry);
  Q_PROPERTY(int retryDelay READ retryDelay WRITE setRetryDelay);

public:
  typedef ctkAbstractTaskPool Superclass;
  explicit ctkDICOMTaskPool(QObject* parent = 0);
  virtual ~ctkDICOMTaskPool();

  /// Query Studies applying filters on all servers.
  /// The method spans a ctkDICOMQueryStudiesWorker for each server.
  Q_INVOKABLE void queryStudies(QThread::Priority priority = QThread::LowPriority);

  /// Query Series applying filters on all servers.
  /// The method spans a ctkDICOMQuerySeriesWorker for each server.
  Q_INVOKABLE void querySeries(const QString& studyInstanceUID,
                               QThread::Priority priority = QThread::LowPriority);

  /// Query Instances applying filters on all servers.
  /// The method spans a ctkDICOMQueryInstancesWorker for each server.
  Q_INVOKABLE void queryInstances(const QString& studyInstanceUID,
                                  const QString& seriesInstanceUID,
                                  QThread::Priority priority = QThread::LowPriority);

  /// Retrieve Study.
  /// The method spans a ctkDICOMRetrieveStudyWorker for each server.
  Q_INVOKABLE void retrieveStudy(const QString& studyInstanceUID,
                                 QThread::Priority priority = QThread::LowPriority);

  /// Retrieve Series.
  /// The method spans a ctkDICOMRetrieveSeriesWorker for each server.
  Q_INVOKABLE void retrieveSeries(const QString& studyInstanceUID,
                                  const QString& seriesInstanceUID,
                                  QThread::Priority priority = QThread::LowPriority);

  /// Retrieve SOPInstance.
  /// The method spans a ctkDICOMRetrieveSOPInstanceWorker for each server.
  Q_INVOKABLE void retrieveSOPInstance(const QString& studyInstanceUID,
                                       const QString& seriesInstanceUID,
                                       const QString &SOPInstanceUID,
                                       QThread::Priority priority = QThread::LowPriority);
  
  /// Return the Dicom Database.
  Q_INVOKABLE ctkDICOMDatabase* dicomDatabase() const;
  /// Return Dicom Database as a shared pointer
  /// (not Python-wrappable).
  QSharedPointer<ctkDICOMDatabase> dicomDatabaseShared() const;
  /// Set the Dicom Database.
  Q_INVOKABLE void setDicomDatabase(ctkDICOMDatabase& dicomDatabase);
  /// Set the Dicom Database as a shared pointer
  /// (not Python-wrappable).
  void setDicomDatabase(QSharedPointer<ctkDICOMDatabase> dicomDatabase);

  ///
  /// Filters are keyword/value pairs as generated by
  /// the ctkDICOMWidgets in a human readable (and editable)
  /// format.  The Query is responsible for converting these
  /// into the appropriate dicom syntax for the C-Find
  /// Currently supports the keys: Name, Study, Series, ID, Modalities,
  /// StartDate and EndDate
  /// Key         DICOM Tag                Type        Example
  /// -----------------------------------------------------------
  /// Name        DCM_PatientName          QString     JOHNDOE
  /// Study       DCM_StudyDescription     QString
  /// Series      DCM_SeriesDescription    QString
  /// ID          DCM_PatientID            QString
  /// Modalities  DCM_ModalitiesInStudy    QStringList CT, MR, MN
  /// StartDate   DCM_StudyDate            QString     20090101
  /// EndDate     DCM_StudyDate            QString     20091231
  /// No filter (empty) by default.
  Q_INVOKABLE void setFilters(const QMap<QString, QVariant> &filters);
  Q_INVOKABLE QMap<QString, QVariant> filters()const;

  /// Servers
  Q_INVOKABLE int getNumberOfServers();
  Q_INVOKABLE ctkDICOMServer* getNthServer(int id);
  Q_INVOKABLE ctkDICOMServer* getServer(const char* connectioName);
  Q_INVOKABLE void addServer(ctkDICOMServer* server);
  Q_INVOKABLE void removeServer(const char* connectioName);
  Q_INVOKABLE void removeNthServer(int id);
  Q_INVOKABLE QString getServerNameFromIndex(int id);
  Q_INVOKABLE int getServerIndexFromName(const char* connectioName);

  /// Tasks managment
  Q_INVOKABLE void waitForDone(int msecs = -1);
  Q_INVOKABLE void waitForFinish(int msecs = -1);
  Q_INVOKABLE int totalTasks();
  Q_INVOKABLE void stopAllTasksNotStarted();
  Q_INVOKABLE void deleteAllTasks();
  Q_INVOKABLE void deleteTask(QString taskUID);
  Q_INVOKABLE void stopTasks(const QString& studyInstanceUID,
                             const QString& seriesInstanceUID = "",
                             const QString& sopInstanceUID = "");
  Q_INVOKABLE void raiseRetrieveFramesTasksPriorityForSeries(const QString& studyInstanceUID,
                                                             const QString& seriesInstanceUID,
                                                             QThread::Priority priority = QThread::HighPriority);

  /// Maximum number of concurrent Qthread span by the threadPool in the task pool
  /// NOTE: there is another Qthread span by the ctkDICOMIndexer which is not count in this variable.
  /// default: cpu threads on the system
  int maximumThreadCount() const;
  void setMaximumThreadCount(const int& maximumThreadCount);
  /// Maximum number of retries that the task pool will try on each failed task
  /// default: 3
  int maximumNumberOfRetry() const;
  void setMaximumNumberOfRetry(const int& maximumNumberOfRetry);
  /// Retry delay in millisec
  /// default: 100 msec
  int retryDelay() const;
  void setRetryDelay(const int& retryDelay);

  /// Indexer
  Q_INVOKABLE QSharedPointer<ctkDICOMIndexer> Indexer()const;
  /// Thread Pool
  Q_INVOKABLE QSharedPointer<QThreadPool> threadPool()const;

Q_SIGNALS:
    void progressTaskDetail(ctkDICOMTaskResults*);

public Q_SLOTS:
   void taskStarted();
   void taskFinished();
   void taskCanceled();
   void taskRetry(ctkAbstractTask* task);

protected:
  QScopedPointer<ctkDICOMTaskPoolPrivate> d_ptr;

private:
  Q_DECLARE_PRIVATE(ctkDICOMTaskPool);
  Q_DISABLE_COPY(ctkDICOMTaskPool);
};

#endif
